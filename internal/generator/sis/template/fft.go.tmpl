import (
	"github.com/consensys/gnark-crypto/ecc/bn254/fr"
)

// fft64 is generated by gnark-crypto and contains the unrolled code for FFT (DIF) on 64 elements
// equivalent code: r.Domain.FFT(k, fft.DIF, fft.OnCoset(), fft.WithNbTasks(1))
// twiddlesCoset must be pre-computed from twiddles and coset table, see precomputeTwiddlesCoset
func fft64(a []fr.Element,  twiddlesCoset []fr.Element) {

	{{- /* notes: 
		this function can be updated with larger n
		nbSteps must be updated too such as 1 << nbSteps == n
		butterflies and multiplication are separated for size n = 8, must check perf for larger n
	 */}}
	 {{$tIndex := 0}}
	{{ $n := 64}}
	{{ $m := div $n 2}}
	{{ $split := 1}}
	{{ $split = div $split 1}}
	{{- range $step := reverse (iterate 0 6)}} 

		{{- $offset := 0}}
		{{- range $s := iterate 0 $split}}
			{{- range $i := iterate 0 $m}}
				{{- $j := add $i $offset}}
				{{- $k := add $j $m}}
				a[{{$k}}].Mul(&a[{{$k}}], &twiddlesCoset[{{$tIndex}}])
			{{- end}}
			{{- $offset = add $offset $n}}
			{{- $tIndex = add $tIndex 1}}
		{{- end}}

		{{- $offset := 0}}
		{{- range $s := iterate 0 $split}}
			{{- range $i := iterate 0 $m}}
				{{- $j := add $i $offset}}
				{{- $k := add $j $m}}
				fr.Butterfly(&a[{{$j}}], &a[{{$k}}])
			{{- end}}
			{{- $offset = add $offset $n}}
		{{- end}}
		
		{{- $n = div $n 2}}
		{{- $m = div $n 2}}
		{{- $split = mul $split 2}}
	{{- end}}
}

// precomputeTwiddlesCoset precomputes twiddlesCoset from twiddles and coset table
// it then return all elements in the correct order for the unrolled FFT.
func precomputeTwiddlesCoset(twiddles [][]fr.Element, shifter fr.Element) []fr.Element {
	r := make([][]fr.Element, len(twiddles))
	for i := 0; i < len(twiddles); i++ {
		r[i] = make([]fr.Element, len(twiddles[i]))
		s := shifter
		for k:=0; k <i;k++ {
			s.Mul(&s, &s)
		}
		for j := 0; j < len(twiddles[i]); j++ {
			r[i][j].Mul(&twiddles[i][j], &s)
		}
	}
	toReturn := make([]fr.Element, 0, 63)
	{{ $n := 64}}
	{{ $m := div $n 2}}
	{{ $split := 1}}
	{{ $split = div $split 1}}
	{{- range $step := reverse (iterate 0 6)}} 

		{{- $offset := 0}}
		{{- range $s := iterate 0 $split}}
			toReturn = append(toReturn, r[{{$step}}][{{bitReverse $split $s}}])
		{{- end}}

		{{- $split = mul $split 2}}
	{{- end}}
	return toReturn
}